[{"uri":"http://localhost:8901/PagePParsing.html","title":"Generic Page - Urls\n","content":"#r \u0022nuget: FSharp.Data, 4.1.1\u0022\n#r \u0022nuget: Newtonsoft.Json, 13.0.1\u0022\n\nopen FSharp.Data\nopen Newtonsoft.Json\nopen System\nopen System.Globalization\nopen System.Xml\n\n(**\n# Generic Page - Urls\n*)\n\nlet tryHref (node: HtmlNode) =\n    let urlHome = \u0022https://www.fool.com\u0022\n    node.TryGetAttribute(\u0022href\u0022)\n    |\u003E Option.map (fun x -\u003E urlHome \u002B x.Value())\n\nlet TranscriptUrls (pageDoc: HtmlDocument): string list= \n    pageDoc.CssSelect(\u0022a[href^=\u0027/earnings/call-transcripts\u0027]\u0022)\n    |\u003E Seq.choose tryHref\n    |\u003E Seq.toList\n\n(**\n# Generic Transcript - Ticker\n*)\n\ntype CssTickerInfo = \n    {CssTicker : string\n     CssExchange: string}\n\nlet tickerExchangeTuple (tickerInfo: string option)=\n    tickerInfo\n    |\u003E function\n    | Some te -\u003E te.Split(\u0022:\u0022) \n                 |\u003E function\n                 | [|exchange; ticker|] -\u003E Some ({CssTicker = ticker\n                                                  CssExchange = exchange})\n                 | _ -\u003E None\n    | _ -\u003E None\n\nlet TickerAndExchange (transcriptDoc: HtmlDocument) = \n    transcriptDoc.CssSelect(\u0022span[class=\u0027ticker\u0027]\u0022)\n    |\u003E Seq.map (fun x -\u003E x.InnerText().Trim())\n    |\u003E Seq.filter (fun x -\u003E not (x.Contains(\u0022(\u0022)))\n    |\u003E Seq.tryExactlyOne\n    |\u003E tickerExchangeTuple\n\n(**\n# Generic Transcript - Date, Time\n*)\n\n// Date\nlet cleanDate (node: HtmlNode) =\n    let dateSplit = node.InnerText().ToUpperInvariant().Replace(\u0022.\u0022, \u0022\u0022).Replace(\u0022,\u0022, \u0022\u0022).Trim().Split(\u0022 \u0022)\n    match dateSplit with\n    |[|month; day; year|] -\u003E Some ($\u0022{month.[..2]} {day} {year}\u0022) \n    | _ -\u003E None\n\nlet TranscriptDate (transcriptDoc: HtmlDocument) =\n    transcriptDoc.CssSelect(\u0022span[id=\u0027date\u0027]\u0022)\n    |\u003E Seq.choose cleanDate\n    |\u003E Seq.tryExactlyOne\n\n// Time\nlet cleanTime (node: HtmlNode) =\n    node.InnerText().ToUpperInvariant().Replace(\u0022.\u0022, \u0022\u0022).Replace(\u0022ET\u0022, \u0022\u0022).Trim()\n\nlet TranscriptTime (transcriptDoc: HtmlDocument) =\n    transcriptDoc.CssSelect(\u0022em[id=\u0027time\u0027]\u0022)\n    |\u003E Seq.map cleanTime\n    |\u003E Seq.tryExactlyOne\n\n// DateTime\nlet exprToDateTime (dateExpr: string) =\n    let dateFormat = \u0022MMM d yyyy h:mm tt\u0022\n    DateTime.ParseExact(dateExpr, dateFormat, System.Globalization.CultureInfo.CurrentCulture)\n\nlet TranscriptDateTime (doc: HtmlDocument) =\n    let timeT = doc |\u003E TranscriptTime \n    let dateT = doc |\u003E TranscriptDate\n    \n    (dateT, timeT)\n    |\u003E function\n    | Some d, Some t -\u003E Some ($\u0022{d} {t}\u0022 |\u003E exprToDateTime) \n    | _ -\u003E None\n\n(**\n# Generic Transcript - Paragraphs\n*)\n\nlet Paragraphs (transcriptDoc: HtmlDocument) = \n    transcriptDoc.CssSelect(\u0022p\u0022)\n    |\u003E Seq.map (fun x -\u003E x.InnerText().Trim())\n    |\u003E Seq.filter (fun x -\u003E x \u003C\u003E \u0022\u0022)\n    |\u003E Seq.fold (fun r s -\u003E r \u002B s \u002B \u0022 \u0022) \u0022\u0022\n    |\u003E string\n\n(**\n# Transcript Record\n- Adding more structure ...\n*)\n\ntype Transcript = \n    {Ticker : string\n     Exchange: string\n     Date : DateTime\n     Paragraphs : string}\n\nlet MatchTranscript =\n    function\n    | Some {CssTicker = ticker; CssExchange = exchange}, Some date, paragraphs -\u003E Some { Ticker = ticker\n                                                                                         Exchange = exchange\n                                                                                         Date = date\n                                                                                         Paragraphs = paragraphs}\n    | _ -\u003E None\n\nlet parseTrancript (transcript: HtmlDocument) = \n    \n    let tickerAndExchange = transcript |\u003E TickerAndExchange\n    let period = transcript |\u003E TranscriptDateTime\n    let paragraphs = transcript |\u003E Paragraphs\n    \n    (tickerAndExchange, period, paragraphs) \n    |\u003E MatchTranscript\n\nlet asyncTranscript (url: string) = \n    async {\n        let! doc = url |\u003E HtmlDocument.AsyncLoad\n        let content = doc |\u003E parseTrancript\n        return content\n        }\n\nlet asyncPage (n: int) = \n    async {\n        printfn $\u0022Page: {n}\u0022\n        let papeP = $\u0022https://www.fool.com/earnings-call-transcripts/?page={n}\u0022\n        \n        let! pageDoc = papeP|\u003E HtmlDocument.AsyncLoad \n\n        let transcripts = \n            pageDoc \n            |\u003E TranscriptUrls \n            |\u003E Seq.map asyncTranscript \n            |\u003E fun xs -\u003E Async.Parallel(xs, 5)\n            |\u003E Async.RunSynchronously\n            |\u003E Seq.choose (\n             function\n             | None -\u003E None\n             | Some t -\u003E Some t)\n\n        return transcripts\n        }\n\n(**\n# Parse Transcript Pages\n*)\n\n(**\nlet asyncTest1to100 = \n    [1 .. 100]\n    |\u003E Seq.map asyncPage\n    |\u003E fun xs -\u003E Async.Parallel(xs, 5)\n    |\u003E Async.RunSynchronously\n    |\u003E Array.collect Seq.toArray\nlet asyncTest = \n    [1 .. 20]\n    |\u003E Seq.map asyncPage\n    |\u003E Async.Parallel\n    |\u003E Async.RunSynchronously\n    |\u003E Array.collect Seq.toArray\nlet asyncPagesContent =\n    [1 .. 144]\n    |\u003E Seq.map asyncPage\n    |\u003E Async.Parallel\n    |\u003E Async.RunSynchronously\n    |\u003E Array.collect Seq.toArray\n*)\n\n(**\n# Export to json\n*)\n\nlet TranscriptsToJson (transcripts: Transcript [], fileName: string) = \n    JsonConvert.SerializeObject(transcripts)\n    |\u003E fun json -\u003E IO.File.WriteAllText(fileName, json)\n\n(**\nTranscriptsToJson (asynchTest1to100, \u0022data-cache/Motley100.json\u0022)\nTranscriptsToJson (asyncTest1to300, \u0022data-cache/EarningsCallTest200.json\u0022)\nTranscriptsToJson (asyncTest, \u0022data-cache/EarningsCallTest.json\u0022)\nTranscriptsToJson (asyncPagesContent, \u0022EarningsTranscripts.json\u0022)\n*)"},{"uri":"http://localhost:8901/Common.html","title":"Common","content":"#r \u0022nuget: FSharp.Data\u0022\n#load \u0022/Users/antonioelias/Desktop/Nova SBE Modules/Data Analytics for Finance/secrets.fsx\u0022\n\nopen System\nopen System.IO\nopen FSharp.Data\n\ntype Frequency = Daily | Monthly\ntype ReturnObs = { Symbol : string; Date : DateTime; Return : float }\n\nmodule Tiingo =\n\n    type TiingoCsv = CsvProvider\u003C\u0022date,close,high,low,open,volume,adjClose,adjHigh,adjLow,adjOpen,adjVolume,divCash,splitFactor\n2020-10-01,9.77,10.25,9.69,10.09,4554055,9.77,10.25,9.69,10.09,4554055.0,0.0,1.0\u0022\u003E\n\n    type TiingoRequest = { Symbol : string; Start : DateTime; End : DateTime }\n\n    type TiingoObs =\n        {\n            Date : DateTime\n            Close : decimal\n            High : decimal\n            Low : decimal\n            Open : decimal \n            Volume : int\n            AdjClose : decimal\n            AdjHigh : decimal\n            AdjLow : decimal\n            AdjOpen : decimal\n            AdjVolume : decimal\n            DivCash : decimal\n            SplitFactor : decimal\n        }\n\n    ///\u003Csummary\u003EConstructs a Tiingo request. By default is to get the past year of data.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022symbol\u0022\u003EThe ticker symbol such as \u0022AAPL\u0022,\u0022MSFT\u0022 etc.\u003C/param\u003E\n    let request symbol = { Symbol = symbol; Start = DateTime.Now.AddYears(-1); End = DateTime.Now}\n    ///\u003Csummary\u003ESets the Tiingo request start date.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022startOn\u0022\u003ERequest start date\u003C/param\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to update.\u003C/param\u003E\n    let startOn startOn request = { request with Start = startOn }\n    ///\u003Csummary\u003ESets the Tiingo request end date.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022endOn\u0022\u003ERequest start date\u003C/param\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to update.\u003C/param\u003E\n    let endOn endOn request = { request with End = endOn }\n\n    let private cache = Runtime.Caching.createInMemoryCache (TimeSpan(hours=12,minutes=0,seconds=0))\n\n    ///\u003Csummary\u003EDownloads Tiingo data.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to download.\u003C/param\u003E\n    let get request =\n        let dtStr (x : DateTime) = x.Date.ToString(\u0022yyyy-MM-dd\u0022)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = $\u0022{request.Symbol}-{dtStr request.Start}-{dtStr request.End}.csv\u0022\n        match cache.TryRetrieve(key) with\n        | Some res -\u003E res\n        | None -\u003E\n            let result = \n                Http.RequestString\n                            ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                                httpMethod = \u0022GET\u0022,\n                                query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                            \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022format\u0022,\u0022csv\u0022],\n                                headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv])\n            cache.Set(key,result)\n            result\n        |\u003E TiingoCsv.Parse\n        |\u003E fun parsed -\u003E\n            parsed.Rows\n            |\u003E Seq.map(fun row -\u003E\n                { Date = row.Date\n                  Close = row.Close\n                  High = row.High\n                  Low = row.Low\n                  Open = row.Open\n                  Volume = row.Volume\n                  AdjClose = row.AdjClose\n                  AdjHigh = row.AdjHigh\n                  AdjLow = row.AdjLow\n                  AdjOpen = row.AdjOpen\n                  AdjVolume = row.AdjVolume\n                  DivCash = row.DivCash\n                  SplitFactor = row.SplitFactor \n                  })\n            |\u003E Seq.toArray      \n    \n    // using a class, keeping private for now.\n    type private Download(symbol:string,?startOn:DateTime,?endOn:DateTime) =\n        let startOn = defaultArg startOn (DateTime.Now.AddYears(-1))\n        let endOn = defaultArg endOn (DateTime.Now)\n        let data = get { Symbol = symbol; Start = startOn; End = endOn }\n        member this.Rows = data\n \n    // Probably deprecated\n    let private getFromCacheDirectory cacheDirectory request =\n        let dtStr (x : DateTime) = x.Date.ToString(\u0022yyyy-MM-dd\u0022)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = $\u0022{request.Symbol}-{dtStr request.Start}-{dtStr request.End}.csv\u0022\n        let cacheFile = cacheDirectory \u002B key\n        if File.Exists(cacheFile) then\n            File.ReadAllText(cacheFile)\n        else    \n            let result = \n                Http.RequestString\n                            ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                                httpMethod = \u0022GET\u0022,\n                                query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                            \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022format\u0022,\u0022csv\u0022],\n                                headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv])\n            File.WriteAllText(cacheFile,result)\n            result\n        |\u003E TiingoCsv.Parse\n    \n    let private returnHelper symbol (xs:TiingoObs seq) =\n        xs\n        |\u003E Seq.sortBy(fun x -\u003E x.Date)\n        |\u003E Seq.pairwise\n        |\u003E Seq.map(fun (yesterday, today) -\u003E\n            { Symbol = symbol \n              Date = today.Date\n              Return =  float (today.AdjClose / yesterday.AdjClose) - 1.0})\n        |\u003E Seq.toArray      \n\n    let getReturns request =\n        get request\n        |\u003E (returnHelper request.Symbol)\n\n    // Marking as private so people don\u0027t use it by accident\n    let private getInternetFileCache request =\n        let cache = Runtime.Caching.createInternetFileCache \u0022tiingo\u0022 (TimeSpan.FromDays 30.0)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = request.ToString()\n        match cache.TryRetrieve(key) with\n        | Some res -\u003E res\n        | None -\u003E\n            let res =\n                Http.RequestString\n                        ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                            httpMethod = \u0022GET\u0022,\n                            query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                        \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                        \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                        \u0022format\u0022,\u0022csv\u0022],\n                            headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv ])\n            cache.Set(key, res)\n            res\n        |\u003E TiingoCsv.Parse\n\nmodule French =\n    //open System.Net\n    open System.IO.Compression\n\n    type private FF3Csv = CsvProvider\u003C\u0022Date (string),Mkt-RF,SMB,HML,RF\n        19260701,    0.10,   -0.24,   -0.28,   0.009\u0022\u003E\n    \n    type FF3Obs = \n        { Date : DateTime \n          MktRf : float\n          Smb : float \n          Hml : float\n          Rf : float \n          Frequency : Frequency } \n\n\n    let private frenchDay x = \n        DateTime.ParseExact(x,\n            \u0022yyyyMMdd\u0022,\n            Globalization.CultureInfo.InvariantCulture)\n    let private frenchMonth x = \n        DateTime.ParseExact(x,\n            \u0022yyyyMM\u0022,\n            Globalization.CultureInfo.InvariantCulture)\n\n    let private cache = \n        let today = DateTime.Now\n        let nextMonth = today.AddMonths(1)\n        let eom = DateTime(nextMonth.Year, nextMonth.Month, 1).AddDays(-1.0) \n        Runtime.Caching.createInternetFileCache \u0022French\u0022 (eom - today)\n\n    let private getData (dataset:string) =\n        match cache.TryRetrieve(dataset) with\n        | Some data -\u003E data\n        | None -\u003E\n            //let dataset = \u0022F-F_Research_Data_Factors_CSV\u0022\n            let urlString = $\u0022http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/{dataset}.zip\u0022\n            let request = Http.RequestStream(urlString, httpMethod = \u0022GET\u0022,headers = [HttpRequestHeaders.Accept HttpContentTypes.Any])\n            use archive = new ZipArchive(request.ResponseStream,ZipArchiveMode.Read)\n            let file = archive.GetEntry($\u0022{dataset}\u0022.Replace(\u0022_CSV\u0022,\u0022.CSV\u0022))\n            use reader = new StreamReader(file.Open())\n            let data  = reader.ReadToEnd()\n            cache.Set(dataset,data)\n            data\n    let getFF3 frequency =\n            let (dataset, dateParser) =\n                match frequency with\n                | Monthly -\u003E \u0022F-F_Research_Data_Factors_CSV\u0022, frenchMonth\n                | Daily -\u003E \u0022F-F_Research_Data_Factors_daily_CSV\u0022, frenchDay\n            let data = new StringReader(getData dataset)\n            data.ReadToEnd().Split(\u0022\\r\\n\u0022)\n            |\u003E Array.skipWhile(fun line -\u003E not (line.Contains(\u0022Mkt-RF\u0022)))\n            |\u003E Array.skip 1\n            |\u003E Array.takeWhile(fun line -\u003E line \u003C\u003E \u0022\u0022)\n            |\u003E Array.map(fun line -\u003E \n                let parsedLine = FF3Csv.ParseRows(line).[0] \n                { Date = dateParser parsedLine.Date\n                  MktRf = float parsedLine.\u0060\u0060Mkt-RF\u0060\u0060 / 100.0\n                  Smb = float parsedLine.SMB / 100.0\n                  Hml = float parsedLine.HML / 100.0\n                  Rf = float parsedLine.RF / 100.0 \n                  Frequency = Monthly })\n\nmodule Fred =\n    type Series = CsvProvider\u003C\u0022https://fred.stlouisfed.org/graph/fredgraph.csv?id=GS10\u0022,\n                              Schema=\u0022Date,Value (float)\u0022,\n                              MissingValues=\u0022.\u0022\u003E\n    let private fredUrl series = $\u0022https://fred.stlouisfed.org/graph/fredgraph.csv?id={series}\u0022\n    \n    ///\u003Csummary\u003EGets a FRED data series as a CsvProvider\u003C/summary\u003E\n        /// \u003Cparam name=\u0022series\u0022\u003EThe series name such as GS10, EXUSEU, etc.\u003C/param\u003E\n    let get (series:string) =  Series.Load(fredUrl series)\n    "},{"uri":"http://localhost:8901/ReturnsAroundEarnings.html","title":"Tiingo\n","content":"#r \u0022nuget: FSharp.Data, 4.1.1\u0022\n#r \u0022nuget: Newtonsoft.Json, 13.0.1\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n\n#load \u0022PagePParsing.fsx\u0022\n#load \u0022secrets.fsx\u0022\n#load \u0022Common.fsx\u0022\n\nopen System\nopen FSharp.Data\nopen Newtonsoft.Json\nopen Plotly.NET\n\nopen PagePParsing\nopen Common\n\nEnvironment.CurrentDirectory \u003C- __SOURCE_DIRECTORY__\nfsi.AddPrinter\u003CDateTime\u003E(fun dt -\u003E dt.ToString(\u0022s\u0022))\n\n(**\n## Writing F# code\n*)\n\n/// Reading JSON\nlet readJson (jsonFile: string) =\n    IO.File.ReadAllText(jsonFile)\n    |\u003E fun json -\u003E JsonConvert.DeserializeObject\u003Cseq\u003CTranscript\u003E\u003E(json)\n    \nlet allTranscripts = readJson (\u0022data-cache/Motley100.json\u0022)\n\n(**\n# Tiingo\n\n- Before actually making any Tiingo calls I thought it would be good idea\n  to check if they actually support that ticker ...\n*)\n\ntype TiingoSupportedTickersCsv = CsvProvider\u003CSample=\u0022data-cache/SupportedTiingoTickers.csv\u0022,\n                                             ResolutionFolder = __SOURCE_DIRECTORY__\u003E\n                                           \nlet supportedTiingoTickers = TiingoSupportedTickersCsv.GetSample()\n\nsupportedTiingoTickers.Rows\n|\u003E Seq.map (fun x -\u003E x.Exchange)\n\n// Filtering \u0027allTranscripts\u0027\ntype SupportedTicker = {Exchange : string; Ticker : string}\n\nlet tiingoTickers = \n    supportedTiingoTickers.Rows\n    |\u003E Seq.map (fun xs -\u003E\n    let ex = xs.Exchange.ToString().Trim()\n    let tckr = xs.Ticker.ToString().Trim()\n    {Exchange = ex\n     Ticker = tckr})\n\nlet transcriptTickers = \n    allTranscripts \n    |\u003E Seq.map (fun x -\u003E (x.Exchange, x.Ticker), x) \n    |\u003E Map\n\nlet myTranscripts =\n    tiingoTickers\n    |\u003E Seq.choose (fun x -\u003E \n    match transcriptTickers.TryFind(x.Exchange, x.Ticker) with\n    | Some xs -\u003E Some xs\n    | None -\u003E None)\n\n(**\n# Calls by time of day barplot\n- Eastern Time (ET)\n*)\n\nlet callsByTimeOfDay = \n    myTranscripts\n    |\u003E Seq.countBy (fun x -\u003E x.Date.Hour)\n    |\u003E Seq.sortBy (fun (hour, count) -\u003E hour)\n    |\u003E Chart.Column\n    |\u003E Chart.withTitle $\u0022Earnings Calls by time of day (N: {myTranscripts |\u003E Seq.length})\u0022\n    |\u003E Chart.withX_AxisStyle \u0022Hour\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\n\nlet callsByDay = \n    myTranscripts\n    |\u003E Seq.countBy (fun x -\u003E x.Date.DayOfWeek, x.Date.DayOfWeek.ToString())\n    |\u003E Seq.sortBy fst\n    |\u003E Seq.map(fun ((dayInt, dayString), count) -\u003E dayString, count )\n    |\u003E Chart.Column\n    |\u003E Chart.withTitle $\u0022Earnings Calls by day of week (N: {myTranscripts |\u003E Seq.length})\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\n  \n(**\n# Market returns (SPY)\n- Fetch market returns over the period of interest\n- Prevents multiple tiingo calls\n*)\n\nlet startSample = myTranscripts |\u003E Seq.minBy (fun x -\u003E x.Date) |\u003E fun x -\u003E x.Date.AddDays(-10.)\nlet endSample = myTranscripts |\u003E Seq.maxBy (fun x -\u003E x.Date) |\u003E fun x -\u003E x.Date.AddDays(\u002B10.)\n\nlet spyReturnsMap =\n    \u0022SPY\u0022\n    |\u003E Tiingo.request\n    |\u003E Tiingo.startOn startSample\n    |\u003E Tiingo.endOn endSample\n    |\u003E Tiingo.getReturns\n    |\u003E Seq.map (fun x -\u003E x.Date, x)\n    |\u003E Map\n\n(**\n#\u00A0Splitting observations\n\n- Before market close\n- After market close\n*)\n\n(**\n# Announcement Day Returns\n*)\n\ntype AnnouncementWindow = \n    { Transcript : Transcript \n      TradingDayAfterCall : DateTime }\n\n// Before Mkt Close Example\nlet allBeforeMktObs = myTranscripts |\u003E Seq.filter (fun x -\u003E x.Date.Hour \u003C 16)\nlet obsBefore = allBeforeMktObs |\u003E Seq.filter (fun x -\u003E x.Ticker = \u0022AAP\u0022) |\u003E Seq.exactlyOne\n\n// After Mkt Close Example\nlet allAfterMktObs = myTranscripts |\u003E Seq.filter (fun x -\u003E x.Date.Hour \u003E= 16)\nlet obsAfter = allAfterMktObs |\u003E Seq.head\n\n(**\n# Returns Around Earnings Announcements\n*)\n\n// Types\ntype ReturnsWindow = \n    {Transcript : Transcript\n     ReturnsAroundEarnings : ReturnObs []}\n\ntype AnnouncementDayReturn = \n    { Transcript : Transcript\n      CumulativeReturn : float}\n\nlet TwoWeekReturnWindow (obs: Transcript): ReturnsWindow option =\n    obs.Ticker\n    |\u003E Tiingo.request\n    |\u003E Tiingo.startOn (obs.Date.AddDays(-7.0))\n    |\u003E Tiingo.endOn (obs.Date.AddDays(7.0))\n    |\u003E Tiingo.getReturns\n    |\u003E fun xs -\u003E \n    match xs with\n    | [||] -\u003E None\n    | _ -\u003E Some {Transcript = obs\n                 ReturnsAroundEarnings = xs}\n\nlet postEarningsReturn (obs: ReturnsWindow): ReturnObs option =\n    let eaDay = if obs.Transcript.Date.Hour \u003C 16 then \n                    obs.Transcript.Date \n                else \n                    obs.Transcript.Date.Date.AddDays(1.0)\n\n    obs.ReturnsAroundEarnings \n    |\u003E Seq.tryFind (fun xs -\u003E xs.Date.Date \u003E= eaDay)\n\nlet ThreeDayWindow (obs: ReturnsWindow): ReturnObs [] option=\n    let postEarningsReturn = \n        obs \n        |\u003E postEarningsReturn\n\n    let filteredObs = \n        obs.ReturnsAroundEarnings\n        |\u003E Array.filter (fun x -\u003E spyReturnsMap |\u003E Map.containsKey x.Date)\n\n    filteredObs\n    |\u003E Array.windowed 3\n    |\u003E Array.filter (fun xs -\u003E\n        match postEarningsReturn, (xs |\u003E Array.map (fun xs -\u003E xs.Date)) with\n        | Some retObs, [|d1; d2; d3|] -\u003E retObs.Date = d2.Date.Date\n        | _ -\u003E failwith \u0022why don\u0027t you have 3 items?\u0022)\n    |\u003E Array.tryExactlyOne\n\nlet ReturnsAroundEarningsAnnouncement (obs: ReturnsWindow option) = \n    match obs with \n    | None -\u003E None\n    | Some retWindow -\u003E\n\n        let retAroundEarnings = \n            retWindow \n            |\u003E ThreeDayWindow\n\n        Some {Transcript = retWindow.Transcript\n              ReturnsAroundEarnings = retWindow.ReturnsAroundEarnings}\n\nlet ExcessCumulativeReturnsFromSPY (obs: ReturnObs []) = \n    let adjRet = \n        obs\n        |\u003E Array.choose (fun x -\u003E\n        match spyReturnsMap.TryFind(x.Date) with\n        | None -\u003E None\n        | Some spyObs -\u003E Some {Symbol = x.Symbol\n                               Date = x.Date\n                               Return = x.Return - spyObs.Return})\n    \n    // Cumulative Return\n    (1.0, adjRet)\n    ||\u003E Array.fold (fun acc x -\u003E acc*(1.0\u002B x.Return))\n    |\u003E fun xs -\u003E xs - 1.\n    \nlet AdjustedCumulativeReturns (obs: ReturnsWindow option) =\n    match obs with \n    | None -\u003E None\n    | Some retWindow -\u003E\n\n        let cumRet = retWindow.ReturnsAroundEarnings |\u003E ExcessCumulativeReturnsFromSPY\n\n        Some {Transcript = retWindow.Transcript\n              CumulativeReturn = cumRet}\n\nlet getReturnsAroundAnnouncement (obs: Transcript) =\n    obs\n    |\u003E TwoWeekReturnWindow\n    |\u003E ReturnsAroundEarningsAnnouncement\n    |\u003E AdjustedCumulativeReturns\n\nmyTranscripts |\u003E Seq.length\n\n\n(**\n# Download and Export to json\nlet t1950 = \n    myTranscripts\n    |\u003E Seq.take 1950\n    |\u003E Seq.choose getReturnsAroundAnnouncement\n    |\u003E Seq.toArray\n\nlet AnnouncementDayReturnToJson (transcripts: AnnouncementDayReturn [], fileName: string) = \n    JsonConvert.SerializeObject(transcripts)\n    |\u003E fun json -\u003E IO.File.WriteAllText(fileName, json)\n\nAnnouncementDayReturnToJson (t1950, \u0022data-cache/AnnouncementDay1950.json\u0022)\n*)"}]