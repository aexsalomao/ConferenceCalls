[{"uri":"http://localhost:8901/index.html","title":"Example: Using Literate Script Content\n","content":"(**\n---\ntitle: Literate Script\ncategory: Examples\ncategoryindex: 2\nindex: 1\n---\n# Example: Using Literate Script Content\n\nThis file demonstrates how to write literate F# script\nfiles (\u0060*.fsx\u0060) that can be transformed into nice HTML\nusing the \u0060literate.fsx\u0060 script from the [F# Formatting\npackage](http://fsprojects.github.io/FSharp.Formatting).\n\nAs you can see, a comment starting with double asterisk\nis treated as part of the document and is transformed \nusing Markdown, which means that you can use:\n\n - Unordered or ordered lists \n - Text formatting including **bold** and _emphasis_\n\nAnd numerous other [Markdown][md] features.\n\n [md]: http://daringfireball.net/projects/markdown\n\n## Writing F# code\n\nCode that is not inside comment will be formatted as\na sample snippet.\n*)\n\n/// The Hello World of functional languages!\nlet rec factorial x = \n  if x = 0 then 1 \n  else x * (factorial (x - 1))\n\nlet f10 = factorial 10"},{"uri":"http://localhost:8901/ReturnsAroundEarnings.html","title":"Read transcripts\n","content":"#r \u0022nuget: FSharp.Data, 4.1.1\u0022\n#r \u0022nuget: Newtonsoft.Json, 13.0.1\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n\n#load \u0022PagePParsing.fsx\u0022\n#load \u0022secrets.fsx\u0022\n#load \u0022Common.fsx\u0022\n\nopen System\nopen FSharp.Data\nopen Newtonsoft.Json\nopen Plotly.NET\n\nopen PagePParsing\nopen Common\n\nEnvironment.CurrentDirectory \u003C- __SOURCE_DIRECTORY__\nfsi.AddPrinter\u003CDateTime\u003E(fun dt -\u003E dt.ToString(\u0022s\u0022))\n\n(**\n# Read transcripts\n*)\n\n/// Reading JSON\nlet readJson (jsonFile: string) =\n    IO.File.ReadAllText(jsonFile)\n    |\u003E fun json -\u003E JsonConvert.DeserializeObject\u003Cseq\u003CTranscript\u003E\u003E(json)\n    \nlet allTranscripts = readJson (\u0022data-cache/Motley100.json\u0022)\n\n(**\n# Tiingo\n\n- Before actually making any Tiingo calls I thought it would be good idea\n  to check if they actually support that ticker ...\n*)\n\ntype TiingoSupportedTickersCsv = CsvProvider\u003CSample=\u0022data-cache/SupportedTiingoTickers.csv\u0022,\n                                             ResolutionFolder = __SOURCE_DIRECTORY__\u003E\n                                           \nlet supportedTiingoTickers = TiingoSupportedTickersCsv.GetSample()\n\nsupportedTiingoTickers.Rows\n|\u003E Seq.map (fun x -\u003E x.Exchange)\n\n// Filtering \u0027allTranscripts\u0027\ntype SupportedTicker = {Exchange : string; Ticker : string}\n\nlet tiingoTickers = \n    supportedTiingoTickers.Rows\n    |\u003E Seq.map (fun xs -\u003E\n    let ex = xs.Exchange.ToString().Trim()\n    let tckr = xs.Ticker.ToString().Trim()\n    {Exchange = ex\n     Ticker = tckr})\n\nlet transcriptTickers = \n    allTranscripts \n    |\u003E Seq.map (fun x -\u003E (x.Exchange, x.Ticker), x) \n    |\u003E Map\n\nlet myTranscripts =\n    tiingoTickers\n    |\u003E Seq.choose (fun x -\u003E \n    match transcriptTickers.TryFind(x.Exchange, x.Ticker) with\n    | Some xs -\u003E Some xs\n    | None -\u003E None)\n\n(**\n# Calls by time of day barplot\n- Eastern Time (ET)\n*)\n\nlet callsByTimeOfDay = \n    myTranscripts\n    |\u003E Seq.countBy (fun x -\u003E x.Date.Hour)\n    |\u003E Seq.sortBy (fun (hour, count) -\u003E hour)\n    |\u003E Chart.Column\n    |\u003E Chart.withTitle $\u0022Earnings Calls by time of day (N: {myTranscripts |\u003E Seq.length})\u0022\n    |\u003E Chart.withX_AxisStyle \u0022Hour\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\n\nlet callsByDay = \n    myTranscripts\n    |\u003E Seq.countBy (fun x -\u003E x.Date.DayOfWeek, x.Date.DayOfWeek.ToString())\n    |\u003E Seq.sortBy fst\n    |\u003E Seq.map(fun ((dayInt, dayString), count) -\u003E dayString, count )\n    |\u003E Chart.Column\n    |\u003E Chart.withTitle $\u0022Earnings Calls by day of week (N: {myTranscripts |\u003E Seq.length})\u0022\n    |\u003E Chart.withY_AxisStyle \u0022Count\u0022\n  \n(**\n# Market returns (SPY)\n- Fetch market returns over the period of interest\n- Prevents multiple tiingo calls\n*)\n\nlet startSample = myTranscripts |\u003E Seq.minBy (fun x -\u003E x.Date) |\u003E fun x -\u003E x.Date.AddDays(-10.)\nlet endSample = myTranscripts |\u003E Seq.maxBy (fun x -\u003E x.Date) |\u003E fun x -\u003E x.Date.AddDays(\u002B10.)\n\nlet spyReturnsMap =\n    \u0022SPY\u0022\n    |\u003E Tiingo.request\n    |\u003E Tiingo.startOn startSample\n    |\u003E Tiingo.endOn endSample\n    |\u003E Tiingo.getReturns\n    |\u003E Seq.map (fun x -\u003E x.Date, x)\n    |\u003E Map\n\n(**\n#\u00A0Splitting observations\n\n- Before market close\n- After market close\n*)\n\n(**\n# Announcement Day Returns\n*)\n\ntype AnnouncementWindow = \n    { Transcript : Transcript \n      TradingDayAfterCall : DateTime }\n\n// Before Mkt Close Example\nlet allBeforeMktObs = myTranscripts |\u003E Seq.filter (fun x -\u003E x.Date.Hour \u003C 16)\nlet obsBefore = allBeforeMktObs |\u003E Seq.filter (fun x -\u003E x.Ticker = \u0022AAP\u0022) |\u003E Seq.exactlyOne\n\n// After Mkt Close Example\nlet allAfterMktObs = myTranscripts |\u003E Seq.filter (fun x -\u003E x.Date.Hour \u003E= 16)\nlet obsAfter = allAfterMktObs |\u003E Seq.head\n\n(**\n# Returns Around Earnings Announcements\n*)\n\n// Types\ntype ReturnsWindow = \n    {Transcript : Transcript\n     ReturnsAroundEarnings : ReturnObs []}\n\ntype AnnouncementDayReturn = \n    { Transcript : Transcript\n      CumulativeReturn : float}\n\nlet TwoWeekReturnWindow (obs: Transcript): ReturnsWindow option =\n    obs.Ticker\n    |\u003E Tiingo.request\n    |\u003E Tiingo.startOn (obs.Date.AddDays(-7.0))\n    |\u003E Tiingo.endOn (obs.Date.AddDays(7.0))\n    |\u003E Tiingo.getReturns\n    |\u003E fun xs -\u003E \n    match xs with\n    | [||] -\u003E None\n    | _ -\u003E Some {Transcript = obs\n                 ReturnsAroundEarnings = xs}\n\nlet postEarningsReturn (obs: ReturnsWindow): ReturnObs option =\n    let eaDay = if obs.Transcript.Date.Hour \u003C 16 then \n                    obs.Transcript.Date \n                else \n                    obs.Transcript.Date.Date.AddDays(1.0)\n\n    obs.ReturnsAroundEarnings \n    |\u003E Seq.tryFind (fun xs -\u003E xs.Date.Date \u003E= eaDay)\n\nlet ThreeDayWindow (obs: ReturnsWindow): ReturnObs [] option=\n    let postEarningsReturn = \n        obs \n        |\u003E postEarningsReturn\n\n    let filteredObs = \n        obs.ReturnsAroundEarnings\n        |\u003E Array.filter (fun x -\u003E spyReturnsMap |\u003E Map.containsKey x.Date)\n\n    filteredObs\n    |\u003E Array.windowed 3\n    |\u003E Array.filter (fun xs -\u003E\n        match postEarningsReturn, (xs |\u003E Array.map (fun xs -\u003E xs.Date)) with\n        | Some retObs, [|d1; d2; d3|] -\u003E retObs.Date = d2.Date.Date\n        | _ -\u003E failwith \u0022why don\u0027t you have 3 items?\u0022)\n    |\u003E Array.tryExactlyOne\n\nlet ReturnsAroundEarningsAnnouncement (obs: ReturnsWindow option) = \n    match obs with \n    | None -\u003E None\n    | Some retWindow -\u003E\n\n        let retAroundEarnings = \n            retWindow \n            |\u003E ThreeDayWindow\n\n        Some {Transcript = retWindow.Transcript\n              ReturnsAroundEarnings = retWindow.ReturnsAroundEarnings}\n\nlet ExcessCumulativeReturnsFromSPY (obs: ReturnObs []) = \n    let adjRet = \n        obs\n        |\u003E Array.choose (fun x -\u003E\n        match spyReturnsMap.TryFind(x.Date) with\n        | None -\u003E None\n        | Some spyObs -\u003E Some {Symbol = x.Symbol\n                               Date = x.Date\n                               Return = x.Return - spyObs.Return})\n    \n    // Cumulative Return\n    (1.0, adjRet)\n    ||\u003E Array.fold (fun acc x -\u003E acc*(1.0\u002B x.Return))\n    |\u003E fun xs -\u003E xs - 1.\n    \nlet AdjustedCumulativeReturns (obs: ReturnsWindow option) =\n    match obs with \n    | None -\u003E None\n    | Some retWindow -\u003E\n\n        let cumRet = retWindow.ReturnsAroundEarnings |\u003E ExcessCumulativeReturnsFromSPY\n\n        Some {Transcript = retWindow.Transcript\n              CumulativeReturn = cumRet}\n\nlet getReturnsAroundAnnouncement (obs: Transcript) =\n    obs\n    |\u003E TwoWeekReturnWindow\n    |\u003E ReturnsAroundEarningsAnnouncement\n    |\u003E AdjustedCumulativeReturns\n\nmyTranscripts |\u003E Seq.length\n\n\n(**\n# Download and Export to json\nlet t1950 = \n    myTranscripts\n    |\u003E Seq.take 1950\n    |\u003E Seq.choose getReturnsAroundAnnouncement\n    |\u003E Seq.toArray\n\nlet AnnouncementDayReturnToJson (transcripts: AnnouncementDayReturn [], fileName: string) = \n    JsonConvert.SerializeObject(transcripts)\n    |\u003E fun json -\u003E IO.File.WriteAllText(fileName, json)\n\nAnnouncementDayReturnToJson (t1950, \u0022data-cache/AnnouncementDay1950.json\u0022)\n*)"}]